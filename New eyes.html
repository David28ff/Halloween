<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Glowing Eyes Toggle Size & Mouth (Teeth Red/Green Glow + Mic Mouth + Gamepad)</title>
  <style>
    /* Video background styling */
    #fog-video {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      z-index: -1;
      pointer-events: none;
    }

    body {
      margin: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      overflow-x: hidden;
      transition: background-color 0.3s ease;
      background: transparent;
      font-family: Arial, sans-serif;
    }

    .face-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      width: 700px;
      height: 350px;
      transition: width 0.4s ease, height 0.4s ease, transform 0.3s ease;
      /* We'll use transform for floating animation */
    }

    .eyes-row {
      display: flex;
      justify-content: center;
      gap: 100px;
      width: 100%;
      transition: gap 0.4s ease;
    }

    .eye-container {
      width: 350px;
      height: 350px;
      position: relative;
      will-change: transform;
      transition: width 0.4s ease, height 0.4s ease;
    }

    .eye-wrapper {
      width: 100%;
      height: 100%;
      position: relative;
    }

    .eye {
      width: 100%;
      height: auto;
      display: block;
      position: relative;
      z-index: 1;
      pointer-events: none;
      transition: filter 0.3s ease, opacity 0.1s ease-in-out 0.1s;
      user-select: none;
    }

    .eye.green-glow {
      filter:
        hue-rotate(90deg)
        brightness(1.3)
        drop-shadow(0 0 8px #00ff00)
        drop-shadow(0 0 14px #00ff00)
        drop-shadow(0 0 20px #00ff00);
    }

    .eye.red-glow {
      filter:
        drop-shadow(0 0 8px #fe0000)
        drop-shadow(0 0 14px #fe0000)
        drop-shadow(0 0 20px #fe0000);
    }

    .veins {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 125%;
      height: 125%;
      pointer-events: none;
      z-index: 1.5;
      opacity: 0.5;
      mix-blend-mode: screen;
      transform: translate(-50%, -50%);
      transition: opacity 0.15s ease-in-out, filter 0.3s ease;
      filter:
        drop-shadow(0 0 6px #fe0000)
        drop-shadow(0 0 12px #fe0000);
    }

    .veins.green-glow {
      filter:
        hue-rotate(90deg)
        brightness(1.3)
        drop-shadow(0 0 6px #00ff00)
        drop-shadow(0 0 12px #00ff00);
      opacity: 0.7;
    }

    .shadow-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 160px;
      height: 160px;
      border-radius: 50%;
      background: radial-gradient(circle at center, rgba(0,0,0,0.6) 20%, rgba(0,0,0,0.1) 60%, transparent 80%);
      z-index: 3;
      pointer-events: none;
      transform: translate(-50%, -50%);
      transition: transform 0.05s linear;
    }

    .pupil {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 70px;
      height: 70px;
      background: black;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      z-index: 4;
      box-shadow:
        0 0 10px 4px rgba(0, 0, 0, 0.6),
        0 0 5px 2px rgba(0, 0, 0, 0.8),
        inset 0 0 8px 2px rgba(0, 0, 0, 0.7);
      transition: transform 0.2s ease, width 0.2s ease, height 0.2s ease;
      user-select: none;
    }

    .highlight {
      position: absolute;
      top: 20%;
      left: 30%;
      width: 20px;
      height: 20px;
      background: white;
      border-radius: 50%;
      filter: drop-shadow(0 0 8px white);
      z-index: 5;
      user-select: none;
      transition: width 0.2s ease, height 0.2s ease;
    }

    .mouth-container {
      position: relative;
      width: 350px;
      height: 140px;
      margin-top: -25px;
      opacity: 0;
      pointer-events: none;
      user-select: none;
      transition: opacity 1s ease, transform 0.4s ease;
      transform-origin: center bottom;
    }

    .mouth-container img.mouth {
      position: absolute;
      left: 0;
      width: 100%;
      height: auto;
      margin: 0;
      user-select: none;
      pointer-events: none;
      filter:
        drop-shadow(0 0 8px #fe0000)
        drop-shadow(0 0 14px #fe0000)
        drop-shadow(0 0 20px #fe0000);
      transition: filter 0.3s ease, transform 0.1s ease;
    }

    .mouth-container img.mouth.green-glow {
      filter:
        hue-rotate(90deg)
        brightness(1.3)
        drop-shadow(0 0 8px #00ff00)
        drop-shadow(0 0 14px #00ff00)
        drop-shadow(0 0 20px #00ff00);
    }

    .mouth-container img.mouth:first-child {
      top: 0;
      transform-origin: center bottom;
    }

    .mouth-container img.mouth:last-child {
      top: 80px;
      transform-origin: center top;
    }

    body.small-layout .face-container {
      width: 400px;
      height: 450px;
    }

    body.small-layout .eyes-row {
      gap: 60px;
      justify-content: center;
    }

    body.small-layout .eye-container {
      width: 175px;
      height: 175px;
    }

    body.small-layout .pupil {
      width: 35px;
      height: 35px;
    }

    body.small-layout .highlight {
      width: 10px;
      height: 10px;
      top: 20%;
      left: 30%;
    }

    body.small-layout .shadow-overlay {
      width: 80px;
      height: 80px;
    }
  </style>
</head>
<body>

<video id="fog-video" autoplay muted loop playsinline>
  <source src="fog/smoke.mp4" type="video/mp4" />
  Your browser does not support the video tag.
</video>

<div class="face-container" id="face-container">
  <div class="eyes-row">
    <div class="eye-container">
      <div class="eye-wrapper" id="left-eye">
        <img src="veins2.svg" alt="Veins" class="veins" />
        <img src="left.svg" alt="Left Eye" class="eye red-glow" />
        <div class="shadow-overlay"></div>
        <div class="pupil"><div class="highlight"></div></div>
      </div>
    </div>
    <div class="eye-container">
      <div class="eye-wrapper" id="right-eye">
        <img src="veins2.svg" alt="Veins" class="veins" />
        <img src="right.svg" alt="Right Eye" class="eye red-glow" />
        <div class="shadow-overlay"></div>
        <div class="pupil"><div class="highlight"></div></div>
      </div>
    </div>
  </div>

  <div class="mouth-container" id="mouth-container">
    <img src="upper-teeth.svg" alt="Upper Teeth" class="mouth red-glow" />
    <img src="lower-teeth.svg" alt="Lower Teeth" class="mouth red-glow" />
  </div>
</div>

<script>
  const leftEye = document.getElementById('left-eye');
  const rightEye = document.getElementById('right-eye');
  const leftPupil = leftEye.querySelector('.pupil');
  const rightPupil = rightEye.querySelector('.pupil');
  const leftShadow = leftEye.querySelector('.shadow-overlay');
  const rightShadow = rightEye.querySelector('.shadow-overlay');
  const leftVeins = leftEye.querySelector('.veins');
  const rightVeins = rightEye.querySelector('.veins');
  const mouthContainer = document.getElementById('mouth-container');
  const mouthTeeth = mouthContainer.querySelectorAll('.mouth');
  const faceContainer = document.getElementById('face-container');

  const bigPupilWidth = 70;
  const bigPupilHeight = 70;
  const smallPupilWidth = 35;
  const smallPupilHeight = 35;

  let movementScale = 0.6;
  let smallLayout = false;
  let greenMode = false;
  let prevButton0 = false;
  let prevButton1 = false;
  let prevTrigger = false;

  let leftMaxX, leftMaxY, rightMaxX, rightMaxY;
  let leftRadius, rightRadius;
  let currentLeftX = 0, currentLeftY = 0;
  let currentRightX = 0, currentRightY = 0;
  const easeFactorActive = 0.25;
  const easeFactorReturn = 0.2;

  // Mouth open parameters
  const maxMouthOpen = 80;  // max vertical pixels to open mouth
  const mouthCloseSpeed = 0.3; // speed of mouth closing (higher = faster)

  let mouthOpenAmount = 0; // current mouth open in px

  // Floating animation state & scale oscillation
  let floating = false;
  let floatAngle = 0;
  let floatRadius = 12; // pixels for translation floating
  let floatSpeed = 0.04; // radians per frame for floating
  let scaleAngle = 0; // radians for scale oscillation
  let scaleSpeed = 0.06; // speed of scaling oscillation
  let minScale = 0.95;
  let maxScale = 1.1;

  function calculateMaxMovement() {
    const leftRect = leftEye.getBoundingClientRect();
    const pupilWidth = smallLayout ? smallPupilWidth : bigPupilWidth;
    const pupilHeight = smallLayout ? smallPupilHeight : bigPupilHeight;

    movementScale = smallLayout ? 0.25 : 0.9;

    leftMaxX = (leftRect.width / 2) - (pupilWidth / 2);
    leftMaxY = (leftRect.height / 2) - (pupilHeight / 2);
    leftRadius = Math.min(leftMaxX, leftMaxY) * movementScale;

    const rightRect = rightEye.getBoundingClientRect();
    rightMaxX = (rightRect.width / 2) - (pupilWidth / 2);
    rightMaxY = (rightRect.height / 2) - (pupilHeight / 2);
    rightRadius = Math.min(rightMaxX, rightMaxY) * movementScale;
  }

  function clampToCircle(x, y, radius) {
    const dist = Math.sqrt(x * x + y * y);
    if (dist > radius) {
      const scale = radius / dist;
      return { x: x * scale, y: y * scale };
    }
    return { x, y };
  }

  function lerp(a, b, t) {
    return a + (b - a) * t;
  }

  function updatePupilsSmooth(targetX, targetY) {
    targetX = Math.max(-1, Math.min(1, targetX));
    targetY = Math.max(-1, Math.min(1, targetY));

    let leftTargetX = targetX * leftMaxX * movementScale;
    let leftTargetY = targetY * leftMaxY * movementScale;
    let rightTargetX = targetX * rightMaxX * movementScale;
    let rightTargetY = targetY * rightMaxY * movementScale;

    const leftClamped = clampToCircle(leftTargetX, leftTargetY, leftRadius);
    const rightClamped = clampToCircle(rightTargetX, rightTargetY, rightRadius);

    const inputMagnitude = Math.sqrt(targetX * targetX + targetY * targetY);
    const ease = inputMagnitude < 0.1 ? easeFactorReturn : (smallLayout ? easeFactorActive : 0.35);

    currentLeftX = lerp(currentLeftX, leftClamped.x, ease);
    currentLeftY = lerp(currentLeftY, leftClamped.y, ease);
    currentRightX = lerp(currentRightX, rightClamped.x, ease);
    currentRightY = lerp(currentRightY, rightClamped.y, ease);

    leftPupil.style.transform = `translate(calc(-50% + ${currentLeftX}px), calc(-50% + ${currentLeftY}px))`;
    leftShadow.style.transform = `translate(calc(-50% + ${currentLeftX}px), calc(-50% + ${currentLeftY}px))`;
    rightPupil.style.transform = `translate(calc(-50% + ${currentRightX}px), calc(-50% + ${currentRightY}px))`;
    rightShadow.style.transform = `translate(calc(-50% + ${currentRightX}px), calc(-50% + ${currentRightY}px))`;
  }

  function toggleGreenGlow(enable) {
    document.querySelectorAll('.eye').forEach(e => {
      e.classList.remove('green-glow', 'red-glow');
      e.classList.add(enable ? 'green-glow' : 'red-glow');
    });
    document.querySelectorAll('.veins').forEach(v => v.classList.toggle('green-glow', enable));
    mouthTeeth.forEach(m => {
      m.classList.remove('red-glow', 'green-glow');
      m.classList.add(enable ? 'green-glow' : 'red-glow');
    });
  }

  function applyLayout() {
    if (smallLayout) {
      document.body.classList.add('small-layout');
      mouthContainer.style.pointerEvents = 'auto';
      mouthContainer.style.opacity = '0';
      mouthContainer.style.transform = 'scale(0.595) translateY(0)';
      setTimeout(() => {
        mouthContainer.style.opacity = '1';
      }, 50);
    } else {
      document.body.classList.remove('small-layout');
      mouthContainer.style.opacity = '0';
      setTimeout(() => {
        if (!smallLayout) mouthContainer.style.pointerEvents = 'none';
      }, 1000);
      mouthContainer.style.transform = 'scale(1) translateY(0)';
    }

    calculateMaxMovement();
    updatePupilsSmooth(0, 0);
  }

  // Breathing animation for eyes and mouth
  function breathe(timestamp) {
    const breathPeriod = 4000;
    const breathAmplitude = 10;
    if (!window._startTime) window._startTime = timestamp;
    const elapsed = timestamp - window._startTime;
    const breathOffset = Math.sin((elapsed / breathPeriod) * 2 * Math.PI) * breathAmplitude;
    const veinOffset = breathOffset * 0.25;

    leftEye.style.transform = `translateY(${breathOffset}px)`;
    rightEye.style.transform = `translateY(${breathOffset}px)`;

    leftVeins.style.transform = `translate(calc(-50%), calc(-50% + ${veinOffset}px))`;
    rightVeins.style.transform = `translate(calc(-50%), calc(-50% + ${veinOffset}px))`;

    mouthContainer.style.transform = `scale(${smallLayout ? 0.595 : 1}) translateY(${breathOffset}px) translateZ(0)`;

    if (!floating) {
      faceContainer.style.transform = 'none';
    }

    requestAnimationFrame(breathe);
  }

  // Mic setup and mouth animation
  async function setupMic() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const audioCtx = new AudioContext();
      const source = audioCtx.createMediaStreamSource(stream);
      const analyser = audioCtx.createAnalyser();
      analyser.fftSize = 512;
      source.connect(analyser);

      const dataArray = new Uint8Array(analyser.frequencyBinCount);

      function updateMouth() {
        analyser.getByteFrequencyData(dataArray);
        // Average of lower frequencies for loudness approx
        let sum = 0;
        for(let i = 0; i < 10; i++) {
          sum += dataArray[i];
        }
        let avg = sum / 10;

        // Normalize avg (0 to 255) to mouth open (0 to maxMouthOpen)
        const targetOpen = Math.min(avg / 255 * maxMouthOpen * 1.6, maxMouthOpen); // *1.6 for sensitivity boost

        // Smooth approach: open quickly, close faster
        if (targetOpen > mouthOpenAmount) {
          mouthOpenAmount = lerp(mouthOpenAmount, targetOpen, 0.25);
        } else {
          mouthOpenAmount = lerp(mouthOpenAmount, targetOpen, mouthCloseSpeed);
        }

        // Apply transform to upper and lower mouth parts (vertical translation)
        mouthTeeth[0].style.transform = `translateY(-${mouthOpenAmount}px)`;
        mouthTeeth[1].style.transform = `translateY(${mouthOpenAmount}px)`;

        // Fade mouth container in if open beyond threshold
        if (mouthOpenAmount > 2) {
          mouthContainer.style.opacity = '1';
        } else if (!smallLayout) {
          mouthContainer.style.opacity = '0';
        }

        requestAnimationFrame(updateMouth);
      }

      updateMouth();
    } catch (err) {
      console.warn("Microphone access denied or unavailable:", err);
    }
  }

  // Floating motion + scale oscillation when trigger held
  function updateFloating() {
    if (!floating) {
      // Smooth return to normal
      faceContainer.style.transform = 'translate(0, 0) scale(1)';
      return;
    }

    floatAngle += floatSpeed;
    scaleAngle += scaleSpeed;

    const x = Math.sin(floatAngle * 1.3) * floatRadius;
    const y = Math.cos(floatAngle * 1.7) * floatRadius * 0.7;
    const scale = minScale + (Math.sin(scaleAngle) + 1) / 2 * (maxScale - minScale);

    faceContainer.style.transform = `translate(${x.toFixed(2)}px, ${y.toFixed(2)}px) scale(${scale.toFixed(3)})`;
  }

  // Gamepad loop for input
  function gamepadLoop() {
    const gamepads = navigator.getGamepads();
    if (gamepads[0]) {
      const gp = gamepads[0];

      // Button 0 (X) toggles small/large layout
      if (gp.buttons[0].pressed && !prevButton0) {
        smallLayout = !smallLayout;
        applyLayout();
      }
      prevButton0 = gp.buttons[0].pressed;

      // Button 1 (Square) toggles green/red glow
      if (gp.buttons[1].pressed && !prevButton1) {
        greenMode = !greenMode;
        toggleGreenGlow(greenMode);
      }
      prevButton1 = gp.buttons[1].pressed;

      // Button 7 (Right Trigger) triggers floating + scaling
      if (gp.buttons[7].pressed) {
        if (!floating) {
          floating = true;
          floatAngle = 0;
          scaleAngle = 0;
        }
      } else {
        if (floating) {
          floating = false;
          faceContainer.style.transform = 'translate(0, 0) scale(1)';
        }
      }

      // Left stick controls pupil movement (-1 to 1 axes)
      const x = gp.axes[0];
      const y = gp.axes[1];
      updatePupilsSmooth(x, y);
    }

    updateFloating();

    requestAnimationFrame(gamepadLoop);
  }

  // Initialization
  window.addEventListener('resize', () => {
    calculateMaxMovement();
    updatePupilsSmooth(0, 0);
  });

  calculateMaxMovement();
  applyLayout();
  toggleGreenGlow(greenMode);
  gamepadLoop();
  breathe();
  setupMic();
</script>

</body>
</html>
